<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ImgTC | Admin Dashboard</title>
  <link rel="icon" type="image/x-icon" href="/assets/favicon-D1T0dV8_.ico">
  
  <!-- Element Plus CSS -->
  <link rel="stylesheet" href="https://unpkg.com/element-plus@2.4.0/dist/index.css">
  
  <!-- Custom CSS -->
  <style>
    /* å†…è”å…³é”®æ ·å¼ä»¥æé«˜åŠ è½½é€Ÿåº¦ */
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background-color: #f8f9fa;
    }
    
    .header-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      padding: 0 20px;
    }
    
    .title {
      font-size: 24px;
      font-weight: bold;
      color: #409eff;
      cursor: pointer;
      transition: color 0.3s;
    }
    
    .title:hover {
      color: #66b1ff;
    }
    
    .search-card {
      flex: 1;
      max-width: 300px;
      margin: 0 20px;
    }
    
    .stats {
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 8px 12px;
      border-radius: 4px;
      transition: background-color 0.3s;
    }
    
    .stats:hover {
      background-color: #f5f7fa;
    }
    
    .file-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 20px;
      padding: 20px;
    }
    
    .file-item {
      border: 1px solid #e4e7ed;
      border-radius: 8px;
      overflow: hidden;
      transition: all 0.3s;
      cursor: pointer;
      background: white;
    }
    
    .file-item:hover {
      border-color: #409eff;
      box-shadow: 0 2px 12px rgba(64, 158, 255, 0.1);
    }
    
    .file-item.selected {
      border-color: #409eff;
      background-color: #f0f9ff;
    }
    
    .file-preview {
      height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #f8f9fa;
    }
    
    .file-preview img {
      max-width: 100%;
      max-height: 100%;
      object-fit: cover;
    }
    
    .file-info {
      padding: 12px;
    }
    
    .file-name {
      font-weight: 500;
      margin-bottom: 8px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .file-meta {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #909399;
    }
    
    .file-actions {
      padding: 12px;
      border-top: 1px solid #e4e7ed;
      display: flex;
      gap: 8px;
    }
    
    .batch-actions {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      border: 1px solid #e4e7ed;
      display: flex;
      gap: 12px;
      z-index: 1000;
    }
    
    .upload-progress {
      margin-bottom: 20px;
    }
    
    .upload-stats {
      display: flex;
      justify-content: space-between;
      margin-top: 12px;
      font-size: 14px;
      color: #606266;
    }
    
    .upload-logs {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #e4e7ed;
      border-radius: 4px;
      padding: 8px;
    }
    
    .upload-log {
      padding: 4px 0;
      font-size: 12px;
    }
    
    .upload-log.success {
      color: #67c23a;
    }
    
    .upload-log.error {
      color: #f56c6c;
    }
    
    /* å“åº”å¼è®¾è®¡ */
    @media (max-width: 768px) {
      .header-content {
        flex-direction: column;
        gap: 12px;
        padding: 12px;
      }
      
      .search-card {
        max-width: 100%;
        margin: 0;
      }
      
      .file-grid {
        grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
        gap: 12px;
        padding: 12px;
      }
      
      .batch-actions {
        left: 12px;
        right: 12px;
        transform: none;
        width: auto;
      }
    }
  </style>
  
  <!-- Sentry é”™è¯¯ç›‘æ§ -->
  <script src="https://js.sentry-cdn.com/219f636ac7bde5edab2c3e16885cb535.min.js" crossorigin="anonymous"></script>
</head>
<body>
  <div id="app">
    <el-container>
      <el-header>
        <div class="header-content">
          <span class="title" @click="refreshDashboard">Dashboard</span>
          <div class="nav-links" style="margin-left: 24px;">
            <a href="/admin-stats.html" style="color: #409eff; text-decoration: none; font-size: 14px; margin-right: 16px;">ğŸ“Š ç»Ÿè®¡åˆ†æ</a>
            <a href="/admin.html" style="color: #409eff; text-decoration: none; font-size: 14px; margin-right: 16px;">ğŸ“‹ åˆ—è¡¨è§†å›¾</a>
            <a href="/upload.html" style="color: #409eff; text-decoration: none; font-size: 14px;">ğŸ“¤ æ‹–æ‹½ä¸Šä¼ </a>
          </div>
          <div class="search-card">
            <el-input 
              v-model="search" 
              size="default" 
              placeholder="è¾“å…¥å…³é”®å­—æœç´¢"
              clearable
            />
          </div>
          <el-tooltip content="æ‰¹é‡ä¸Šä¼ " placement="bottom">
            <span class="stats" @click="handleUpload">
              <el-icon class="upload-icon" style="margin-right: 8px; color: #409eff;">
                <Upload />
              </el-icon>
              <span class="stats-text">è®°å½•æ•°: </span>{{ totalFiles }}
            </span>
          </el-tooltip>
          <input 
            type="file" 
            ref="fileInputRef" 
            style="display: none;" 
            multiple 
            @change="uploadFiles"
          >
        </div>
      </el-header>

      <el-main>
        <!-- æ–‡ä»¶åˆ—è¡¨ -->
        <div class="file-grid" v-loading="loading">
          <div 
            v-for="item in paginatedData" 
            :key="item.name"
            class="file-item"
            :class="{ 'selected': item.selected }"
            @click="toggleSelection(item)"
          >
            <div class="file-preview">
              <img 
                v-if="isImage(item)" 
                :src="getFileUrl(item)" 
                :alt="item.metadata.fileName"
                @error="handleImageError"
              />
              <div v-else class="file-icon">
                <el-icon size="48"><Document /></el-icon>
              </div>
            </div>
            
            <div class="file-info">
              <div class="file-name" :title="item.metadata.fileName">
                {{ item.metadata.fileName }}
              </div>
              <div class="file-meta">
                <span class="file-size">{{ formatFileSize(item.metadata.fileSize) }}</span>
                <span class="file-date">{{ formatDate(item.metadata.TimeStamp) }}</span>
              </div>
            </div>
            
            <div class="file-actions">
              <el-button 
                type="primary" 
                size="small" 
                @click.stop="copyUrl(item)"
              >
                å¤åˆ¶é“¾æ¥
              </el-button>
              <el-button 
                type="danger" 
                size="small" 
                @click.stop="deleteFile(item)"
              >
                åˆ é™¤
              </el-button>
            </div>
          </div>
        </div>

        <!-- åˆ†é¡µ -->
        <el-pagination
          v-model:current-page="currentPage"
          v-model:page-size="pageSize"
          :page-sizes="[15, 30, 50, 100]"
          :total="filteredData.length"
          layout="total, sizes, prev, pager, next, jumper"
          style="margin: 20px 0; display: flex; justify-content: center;"
        />

        <!-- æ‰¹é‡æ“ä½œ -->
        <div v-if="selectedFiles.length > 0" class="batch-actions">
          <el-button type="danger" @click="batchDelete">
            æ‰¹é‡åˆ é™¤ ({{ selectedFiles.length }})
          </el-button>
          <el-button @click="clearSelection">å–æ¶ˆé€‰æ‹©</el-button>
        </div>
      </el-main>
    </el-container>

    <!-- ä¸Šä¼ è¿›åº¦å¯¹è¯æ¡† -->
    <el-dialog v-model="uploadDialogVisible" title="æ‰¹é‡ä¸Šä¼ " width="600px">
      <div class="upload-progress">
        <el-progress 
          :percentage="uploadProgress" 
          :status="uploadStatus"
          :stroke-width="8"
        />
        <div class="upload-stats">
          <span>å·²å®Œæˆ: {{ uploadCompleted }}</span>
          <span>æ€»æ•°: {{ uploadTotal }}</span>
          <span>å¤±è´¥: {{ uploadFailed }}</span>
        </div>
      </div>
      <div class="upload-logs" v-if="uploadLogs.length > 0">
        <div 
          v-for="(log, index) in uploadLogs" 
          :key="index"
          :class="['upload-log', log.type]"
        >
          {{ log.message }}
        </div>
      </div>
    </el-dialog>
  </div>

  <!-- Vue 3 å’Œ Element Plus -->
  <script src="https://unpkg.com/vue@3.4.0/dist/vue.global.js"></script>
  <script src="https://unpkg.com/element-plus@2.4.0/dist/index.full.js"></script>
  <script src="https://unpkg.com/@element-plus/icons-vue@2.3.0/dist/index.iife.min.js"></script>

  <script>
    const { createApp, ref, reactive, computed, onMounted } = Vue;
    const { ElMessage, ElMessageBox, ElNotification } = ElementPlus;

    const app = createApp({
      setup() {
        // å“åº”å¼æ•°æ®
        const loading = ref(false);
        const search = ref('');
        const currentPage = ref(1);
        const pageSize = ref(15);
        const tableData = ref([]);
        const selectedFiles = ref([]);
        const fileInputRef = ref();

        // ä¸Šä¼ ç›¸å…³
        const uploadDialogVisible = ref(false);
        const uploadProgress = ref(0);
        const uploadStatus = ref('');
        const uploadCompleted = ref(0);
        const uploadTotal = ref(0);
        const uploadFailed = ref(0);
        const uploadLogs = ref([]);

        // é…ç½®å¯¹è±¡
        const uploadConfig = reactive({
          maxSize: 20 * 1024 * 1024,  // æœ€å¤§ä¸Šä¼ 20MB
          maxConcurrent: 3
        });

        // è®¡ç®—å±æ€§
        const totalFiles = computed(() => tableData.value.length);

        const filteredData = computed(() => {
          let data = tableData.value;
          
          // æœç´¢ç­›é€‰
          if (search.value) {
            data = data.filter(item => 
              item.metadata.fileName.toLowerCase().includes(search.value.toLowerCase())
            );
          }
          
          // æŒ‰æ—¶é—´å€’åºæ’åº
          data = [...data].sort((a, b) => b.metadata.TimeStamp - a.metadata.TimeStamp);
          
          return data;
        });

        const paginatedData = computed(() => {
          const start = (currentPage.value - 1) * pageSize.value;
          const end = start + pageSize.value;
          return filteredData.value.slice(start, end);
        });

        // å·¥å…·å‡½æ•°
        const getFileExtension = (filename) => {
          return filename.split('.').pop() || '';
        };

        const isImage = (item) => {
          const ext = getFileExtension(item.name).toLowerCase();
          const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'tiff', 'ico'];
          return imageExts.includes(ext);
        };

        const getFileUrl = (item) => {
          return `${window.location.origin}/file/${item.name}`;
        };

        const formatFileSize = (bytes) => {
          if (!bytes) return '0 B';
          const k = 1024;
          const sizes = ['B', 'KB', 'MB', 'GB'];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        };

        const formatDate = (timestamp) => {
          return new Date(timestamp).toLocaleString('zh-CN');
        };

        // æ–¹æ³•å®šä¹‰
        const refreshDashboard = async () => {
          loading.value = true;
          try {
            const response = await fetch('./api/manage/list', {
              method: 'GET',
              credentials: 'include'
            });
            const result = await response.json();

            tableData.value = result.map(file => ({
              ...file,
              selected: false,
              metadata: {
                ...file.metadata,
                liked: file.metadata.liked ?? false,
                fileName: file.metadata.fileName ?? file.name,
                fileSize: file.metadata.fileSize ?? 0
              }
            }));

            ElMessage.success('æ•°æ®åˆ·æ–°æˆåŠŸ');
          } catch (error) {
            ElMessage.error('åŒæ­¥æ•°æ®æ—¶å‡ºé”™ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
          } finally {
            loading.value = false;
          }
        };

        const handleUpload = () => {
          fileInputRef.value?.click();
        };

        const uploadFiles = async (event) => {
          const files = Array.from(event.target.files);
          if (files.length === 0) return;

          // éªŒè¯æ–‡ä»¶
          const validFiles = files.filter(file => {
            if (file.size > uploadConfig.maxSize) {
              ElMessage.error(`æ–‡ä»¶ ${file.name} è¶…è¿‡å¤§å°é™åˆ¶`);
              return false;
            }
            return true;
          });

          if (validFiles.length === 0) return;

          // æ˜¾ç¤ºä¸Šä¼ å¯¹è¯æ¡†
          uploadDialogVisible.value = true;
          uploadProgress.value = 0;
          uploadCompleted.value = 0;
          uploadTotal.value = validFiles.length;
          uploadFailed.value = 0;
          uploadLogs.value = [];
          uploadStatus.value = '';

          try {
            // åˆ†æ‰¹å¹¶å‘ä¸Šä¼ 
            for (let i = 0; i < validFiles.length; i += uploadConfig.maxConcurrent) {
              const batch = validFiles.slice(i, i + uploadConfig.maxConcurrent);

              await Promise.all(
                batch.map(async (file) => {
                  try {
                    await uploadSingleFile(file);
                    uploadCompleted.value++;
                    uploadLogs.value.push({
                      type: 'success',
                      message: `âœ“ ${file.name} ä¸Šä¼ æˆåŠŸ`
                    });
                  } catch (error) {
                    uploadFailed.value++;
                    uploadLogs.value.push({
                      type: 'error',
                      message: `âœ— ${file.name} ä¸Šä¼ å¤±è´¥: ${error.message}`
                    });
                  }

                  uploadProgress.value = Math.round(
                    ((uploadCompleted.value + uploadFailed.value) / uploadTotal.value) * 100
                  );
                })
              );
            }

            uploadStatus.value = uploadFailed.value > 0 ? 'exception' : 'success';

            ElNotification.success({
              title: 'ä¸Šä¼ å®Œæˆ',
              message: `æˆåŠŸä¸Šä¼  ${uploadCompleted.value} ä¸ªæ–‡ä»¶${uploadFailed.value > 0 ? `ï¼Œå¤±è´¥ ${uploadFailed.value} ä¸ª` : ''}`
            });

            // åˆ·æ–°æ•°æ®
            await refreshDashboard();

          } finally {
            // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
            if (fileInputRef.value) {
              fileInputRef.value.value = '';
            }
          }
        };

        const uploadSingleFile = async (file) => {
          const formData = new FormData();
          formData.append('file', file);

          const response = await fetch('/upload', {
            method: 'POST',
            body: formData
          });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          return await response.json();
        };

        const toggleSelection = (item) => {
          item.selected = !item.selected;
          if (item.selected) {
            selectedFiles.value.push(item);
          } else {
            const index = selectedFiles.value.findIndex(f => f.name === item.name);
            if (index > -1) {
              selectedFiles.value.splice(index, 1);
            }
          }
        };

        const clearSelection = () => {
          selectedFiles.value.forEach(item => {
            item.selected = false;
          });
          selectedFiles.value = [];
        };

        const copyUrl = async (item) => {
          const url = getFileUrl(item);
          try {
            await navigator.clipboard.writeText(url);
            ElMessage.success('é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
          } catch (error) {
            ElMessage.error('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶');
          }
        };

        const deleteFile = async (item) => {
          try {
            await ElMessageBox.confirm(
              `ç¡®å®šè¦åˆ é™¤æ–‡ä»¶ "${item.metadata.fileName}" å—ï¼Ÿ`,
              'ç¡®è®¤åˆ é™¤',
              {
                confirmButtonText: 'ç¡®å®š',
                cancelButtonText: 'å–æ¶ˆ',
                type: 'warning'
              }
            );

            const response = await fetch(`./api/manage/delete/${item.name}`, {
              method: 'GET',
              credentials: 'include'
            });

            if (response.ok) {
              const index = tableData.value.findIndex(f => f.name === item.name);
              if (index > -1) {
                tableData.value.splice(index, 1);
              }
              ElMessage.success('æ–‡ä»¶åˆ é™¤æˆåŠŸ');
            } else {
              ElMessage.error('æ–‡ä»¶åˆ é™¤å¤±è´¥');
            }
          } catch (error) {
            // ç”¨æˆ·å–æ¶ˆåˆ é™¤
          }
        };

        const batchDelete = async () => {
          if (selectedFiles.value.length === 0) return;

          try {
            await ElMessageBox.confirm(
              `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedFiles.value.length} ä¸ªæ–‡ä»¶å—ï¼Ÿ`,
              'æ‰¹é‡åˆ é™¤ç¡®è®¤',
              {
                confirmButtonText: 'ç¡®å®š',
                cancelButtonText: 'å–æ¶ˆ',
                type: 'warning'
              }
            );

            const deletePromises = selectedFiles.value.map(item =>
              fetch(`./api/manage/delete/${item.name}`, {
                method: 'GET',
                credentials: 'include'
              })
            );

            await Promise.all(deletePromises);

            // ä»åˆ—è¡¨ä¸­ç§»é™¤å·²åˆ é™¤çš„æ–‡ä»¶
            selectedFiles.value.forEach(item => {
              const index = tableData.value.findIndex(f => f.name === item.name);
              if (index > -1) {
                tableData.value.splice(index, 1);
              }
            });

            clearSelection();
            ElMessage.success('æ‰¹é‡åˆ é™¤æˆåŠŸ');
          } catch (error) {
            ElMessage.error('æ‰¹é‡åˆ é™¤å¤±è´¥');
          }
        };

        const handleImageError = (event) => {
          event.target.style.display = 'none';
        };

        // ç”Ÿå‘½å‘¨æœŸ
        onMounted(async () => {
          // æ£€æŸ¥ç™»å½•çŠ¶æ€
          try {
            const response = await fetch('./api/manage/check', {
              method: 'GET',
              credentials: 'include'
            });
            const result = await response.text();

            if (result !== 'true') {
              window.location.href = './api/manage/login';
              return;
            }
          } catch (error) {
            ElMessage.error('æ£€æŸ¥ç™»å½•çŠ¶æ€å¤±è´¥');
            return;
          }

          // åŠ è½½æ•°æ®
          await refreshDashboard();
        });

        return {
          loading,
          search,
          currentPage,
          pageSize,
          tableData,
          selectedFiles,
          fileInputRef,
          uploadDialogVisible,
          uploadProgress,
          uploadStatus,
          uploadCompleted,
          uploadTotal,
          uploadFailed,
          uploadLogs,
          totalFiles,
          filteredData,
          paginatedData,
          isImage,
          getFileUrl,
          formatFileSize,
          formatDate,
          refreshDashboard,
          handleUpload,
          uploadFiles,
          toggleSelection,
          clearSelection,
          copyUrl,
          deleteFile,
          batchDelete,
          handleImageError
        };
      }
    });

    // æ³¨å†Œ Element Plus å›¾æ ‡
    for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
      app.component(key, component);
    }

    app.use(ElementPlus);
    app.mount('#app');
  </script>
</body>
</html>
